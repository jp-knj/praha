# 複合インデックスを理解する

## 課題1
**結論**
複合インデックスとは、電話帳の順序付けと似ています。 2列からなるインデックスの順序付けは、最初に姓で並べ替え、さらに名前で並べ替えるということをしています。名前だけで電話帳を引くことはできないように、2列のインデックスは、2番目の列だけでの検索はできません。
「姓」だけでは同じデータが重なってしまう場合に「姓」と「名前」の両方を１つのインデクスにしてしまうことにより、効率よく検索できることを狙っています。

**実行**
```sql
CREATE INDEX employees_name ON 
    employees (last_name, first_name)
```
重要なポイント:  
- 複合インデックスを定義する際に考えるべき最も重要なのは、そのインデックスを使えるSQL文ができるだけ多くなるように、列の順番を決めることです。
- 単独で検索条件に利用されるカラムを先頭にする
- 選択性に優れているカラムから順に指定する
- 検索とソートが関係する複合インデックスは『検索のカラム、ソートのカラム』の順にする

> **フルテーブルスキャンとは?**  
> 全表スキャン（フルテーブルスキャン）は、SQLで指定された表の全てのデータにアクセスして、検索条件を満たす行を1行ずつチェックする方法です。 

### インデックスの働きについて
　B＋ツリーは、データ（インデックスの値）が格納されたリーフノード（葉ノード）と、リーフノードへの経路としての役割を持つノンリーフノードと呼ばれるものがある。
子ノードへのポインタ（多くの場合はページID）が格納されていて、「どの枝を検索すれば目的のインデックスが見つかるか」が分かるようになっている。
なのでB＋ツリーの検索は、ルートノードからあるリーフノードへ至る一本の経路だけを検索すれば発見するので、効率的です。
 インデックスが増えれば増えるほど、更新時のオーバーヘッドと、消費するディスクスペースが増えるため、作成するインデックス

***
**インデックスの左端と範囲検索**  
B＋ツリーインデックスは、等価比較及び範囲検索に利用できる。  
等価比較は、キーの値が完全に一致する行を探します。  
範囲検索は、不等号やBETWEEN句を用いて範囲指定します。  
`WHERE key = 123` や `WHERE key BETWEEN 100 AMD 200` 

インデックスを利用した検索を行うには、ワイルドカードの指定は前方一致にしなければならない。

マルチカラムインデックスの場合も同様です。
たとえば、（last_name, middle_name, first_name)にインデックスが付与されている場合、等価比較や左端ではないカラム（middle_name, first_name)を選択したとしてもインデックスの効果を発揮するのは困難です。  

検索次にインデックスを利用するには、**左端のカラムから順に、インデックスを指定する必要がありますね**  
左端のカラムの値が指定されていれば、残りの値がわからなくても、範囲検索としてインデックスを有効にかつようできます。
***
**参考文献** 
- [インデックスの働きについて](https://amzn.to/3sVCXtA)
- [複合インデックスについて](https://use-the-index-luke.com/ja/sql/where-clause/the-equals-operator/concatenated-keys)

## 課題2
```shell
mysql> select * from employees where first_name ='Satoru' and last_name ='Fujisaki';
+--------+------------+------------+-----------+--------+------------+
| emp_no | birth_date | first_name | last_name | gender | hire_date  |
+--------+------------+------------+-----------+--------+------------+
| 203250 | 1954-07-22 | Satoru     | Fujisaki  | M      | 1989-06-27 |
+--------+------------+------------+-----------+--------+------------+
1 row in set (0.09 sec)


```

```shell
mysql> CREATE INDEX employee_name ON employees (first_name, last_name);
Query OK, 0 rows affected (1.20 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

#### 検索速度
**複合インデックスを使う前:**  
```shell
1 row in set (0.09 sec)
```

**複合インデックスを使った後:**  
```shell
1 row in set (0.00 sec)
```

```shell
mysql> select * from employees where first_name ='Satoru' and last_name ='Fujisaki';
+--------+------------+------------+-----------+--------+------------+
| emp_no | birth_date | first_name | last_name | gender | hire_date  |
+--------+------------+------------+-----------+--------+------------+
| 203250 | 1954-07-22 | Satoru     | Fujisaki  | M      | 1989-06-27 |
+--------+------------+------------+-----------+--------+------------+
1 row in set (0.00 sec)
```
### 複合インデックスが使用される構文について
***
**WHERE句**  
```shell
SELECT * FROM WHERE col1 > 100 AND col2 = 'abc';
```
このクエリをインデックスを使って高速に処理をするには、(col2, col1)という順序でインデックスを作成した方が良い。　　
なぜなら（col1, col2）の順序でインデックスを作成しても、col1 > 100 の部分でしか、B＋ツリーで高速化できないためです。　　

この不等式は、col1の上限はないため、膨大な数の検索結果が該当する可能性がありますが、（col2,col1)の順序で作成されたインデックスであれば、両方の検索条件をインデックスで解決することが可能です。
具体的には、('abc', 100) < (col2,col1) < ('abc', co1の最小値)という範囲をインデックスから検索されることになる。 

**JOIN**
```shell
SELECT * 
FROM t1 
  JOIN t2
    ON t1.col1 = t2.col2
  WHERE t1.col3 = 100 AND t2.col4 = 'abc';
```
このクエリで駆動表がt1、内部表がt2 という順序の実行結果が選択されたとき、t2テーブルにおいて(col2, col4) というマルチカラムインデックスがあると、col2はJOINのON句で、col4は WHERE句で利用されています。　　

これはt2.col2が主キーや一意インデックスでない場合は効果的です。
なぜなら、主キーや一意インデックスでは等価比較によってテーブルから取得されるデータは多くても１行ほどになります。
このクエリの取得を高速化するには、JOIN の条件に従ってt2から行を取得した後に、WHERE句のt2.col4 = 'abc' という条件で、さらに絞り込みが行われる。

なら、t2テーブルに（col2,col4）という複合インデックスがあれば、テーブルからデータが取得される際に JOIN の t1.col1 = t2.col2、WHERE句のt2.col4 = 'abc' という２つの条件の両方が適用されることになる。

なので、テーブルから行を取得して後に、WHERE句の条件でさらに絞り込みが行われる過程を削減できそうですね。

## 課題3
Display the month and total hires for the month with the most hires. 
- 1970年以降のもらった合計給与額が最も高い従業員の氏名と合計額を取得
- 合計給与額が２番目に高い従業員の氏名と合計額を取得 
- イニシャルがQ.Qの従業員一覧を取得 