# 基本的な設計原則 
[課題内容](https://airtable.com/appPxhCPFYGqqN9YU/tblVlFr2q4lIqDKYc/viwX8r6DpCRp80swL/rec4LYaRJr7WFOSrA?blocks=hide)

## 課題１
### SOLID原則のメリットを説明してください

### 単一責任の原則とファイルを分割の相違はなんでしょうか

### OCPの原則に沿ったサンプルコードの実装

### リスコフの置換原則に違反した場合、どのような不都合が生じるでしょうか？

### インターフェースを用いる事で、設計上どのようなメリットがあるでしょうか？

### どんな時に依存性の逆転を用いる必要が生じるのでしょうか？

### デメトルの法則とは何でしょうか？

#### 業務経験1年目のITエンジニアに伝わるように説明してください。

#### この法則を守ることで、どのようなメリットがあるのでしょうか？

#### 以下のコードの保守性に対して効果が無いことを説明してあげてください
##### デメテルの法則を守ることにはどのような意味/効果があるのでしょうか？

[新人1年性が提出したサンプルコード](https://bit.ly/38AXxZN)

## 課題２
えば以下のサンプルコードでは「特定の商品は1人につき年間1つまでしか買えない」といった仕様を実現しようとしています
TypeScript playgroundのサンプルコード
このコードにはどのような問題点が潜んでいるでしょうか？もしあなたが書き換えるとしたら、どのようにこのコードを改修しますか？
Food for thought:
「アプリケーション側ではなくSQLで絞り込む」という改修を思い当たるかもしれません
しかしその場合「過去1年以内に特定の商品を購入した履歴を抽出する」という、特定のドメインロジックに依存したSQLが生まれてしまいます。今後「過去3ヶ月以内に商品を購入した場合は購入不可とする」「プレミアム会員の場合は1年に何個でも購入可能とする」といったロジックが生まれると、それらのロジックがSQLに含まれて、SQLがどんどん複雑に肥大化していきます
一方、アプリケーション側だけで絞り込みを実現しようとすると（今回のように、まず特定ユーザーの過去の購入履歴を全て取得してから絞り込むといったアプローチだと）性能面で問題が起きるかもしれません
どちらの方法もメリットデメリットがありそうですね・・・！（実際そういう問題なので答えはケースバイケースなのですが、どんな時にどちらの選択肢を選ぶか考えてみると面白いかもしれません）
## 課題３
こちらのコードに記載されているようなPersonクラスとCompanyクラスが存在するとします
Personクラスの名前と勤務開始日（name, starWorkingAt）は外部から自由に書き換えられるような状態になっています
この設計にはどのような問題が潜んでいるでしょうか？
どうすれば解決できると思いますか？
ヒント：カプセル化について調べてみると良いかもしれません

### 任意課題
アーキテクトがモジュール性を把握するのに役立つキーとなる考え方に焦点を当てる。

- 凝集度
- 結合度
- コナーセンス

#### 凝集度
モジュールの要素がどの程度、そのモジュールに収まっているかの具合を表す。

- モジュール内の要素同士の関連度を示す座標
凝集度の高いモジュールを分割しようとしても、結合度が増えて可読性が低下

<details>
    <summary>機能的凝集/Functional Cohesion</summary>
    関連する要素だけでもモジュールが構成され、モジュールが機能するために必要不可欠なものがすべて含まれている
</details>

<details>
    <summary>逐次的凝集/Sequential Cohesion</summary>
    一方が出力したデータを、もう一方が入力とする形で、２つのモジュールが相互に作用している。
</details>

<details>
    <summary>通信的凝集度/Communicational Cohesion</summary>
    ２つのモジュールが通信の連鎖を形成し、それぞれの情報を操作したり、何らかの出力に貢献したりする。たとえば、データベースにレコードを追加し、その情報に基づいて電子メールを生成するといった具合
</details>

<details>
    <summary>手続き型凝集度/Procedural Cohesion</summary>
    ２つのモジュールが通信の連鎖を形成し、それぞれの情報を操作したり、何らかの出力に貢献したりする。たとえば、データベースにレコードを追加し、その情報に基づいて電子メールを生成するといった具合
</details>

<details>
    <summary>時間的凝集度/Temporal Cohesion</summary>
    モジュール間に時間的な依存関係がある、たとえば、多くのシステムにはシステム起動時に初期化しなければならない一見無関係な処理群が存在している。これらの異なる処理には時間的な凝集があるといえる。
</details>

<details>
    <summary>論理的凝集度/Logical Cohesion</summary>
    モジュール内のデータは論理的に関連しているものの、機能的には関連していない。たとえば、テキストやシリアライズされたオブジェクト、またはストリームを情報へ変換するモジュールを考える。
    この場合、これらは操作の上では関連があるものの、機能は全く異なる。
</details>

<details>
    <summary>偶発的凝集度/Coincidental Cohesion</summary>
    モジュール内の要素は同じソースファイル内にある以外には関連性がない。これは最悪な形での凝集を表している。
</details>

#### 結合度
- 求心性結合
コードアーティファクト（コンポーネント、クラス、関数など）に外部から入力される接続数を計測
- 遠心性結合
他のコードアーティファクト（コンポーネント、クラス、関数など）に外部から出力する接続数を計測

#### コナーセンス
システムの全体的な正しさを維持するため、あるコンポーネントの変更が別のコンポーネントの変更を必要とする場合、2つのコンポーネントはコナーセント(接続)されている。
