# フロントエンドのレンダリングパターンを学ぶ 
[課題内容](https://airtable.com/appPxhCPFYGqqN9YU/tblVlFr2q4lIqDKYc/viwX8r6DpCRp80swL/recSzfRld0OfLXrDl?blocks=hide)

## 課題1
Q.SSR, CSR, SSG の違いをペアに説明してください。

- SSR とは
  - Server Side Rendering は クライアントサイドのアプリケーションをサーバ上でHTMLにレンダリングすること
- CSR とは
  - Client Side Rendering は　ブラウザでアプリをレンダリングすることで、DOMを使用する
- SSG とは
  - Static Site Generation は　クライアントサイドのアプリケーションをビルド時に実行して、その初期状態を `static site` としてレンダリングすること

- Rehydration について
  - server でレンダリングされたHTMLのDOMツリーとデータを再利用するように、クライアントでJavaScriptによる機能を付与すること

各レンダリングパターンを下記のパフォーマンス観点で説明する
- TTFB: 
  - Time to First Byte
  - link をクリックしてから、最初のコンテンツが表示されるまでの時間のこと。
- FP 
  - First Paint（ファーストペイント） 
  - ピクセルがユーザーに見えるようになる最初の時間のこと。
- FCP: 
  - First Contentful Paint 
  - 要求されたコンテンツ（記事本文など）が見えるようになるまでの時間のこと。
- TTI: 
  - Time To Interactive 
  - ページがインタラクティブになる時間のこと

### より詳細に Server Side Rendering を説明する
サーバーレンダリングは、ナビゲーションに応答して、サーバー上にページの完全なHTMLを生成する。
これにより、ブラウザが応答を取得する前に処理されるため、クライアントでのデータ取得やテンプレート作成のための追加ラウンドトリップを回避することができます。
サーバーレンダリングは一般に、ファーストペイント（FP）とファーストコンテントフルペイント（FCP）を高速に実行します。
ページ ロジックとレンダリングをサーバーで実行すると、クライアントに大量の JavaScript を送信する必要がなくなるため、Time to Interactive（TTI）が高速になります。
サーバーレンダリングでは、ユーザーのブラウザにテキストとリンクを送信するだけなので、これは理にかなっています。
この方法は、さまざまなデバイスやネットワークの条件に対して有効であり、ストリーミング ドキュメントの解析など、興味深いブラウザの最適化の可能性が広がります。

サーバーレンダリングを使用すれば、ユーザーがサイトを利用する前に、CPUに負荷のかかるJavaScriptの処理を待たされることはまずありません。
サードパーティのJSが避けられない場合でも、サーバーレンダリングを使用してファーストパーティのJSのコストを削減すれば、その他のJSのための「予算」を確保することができます。
サーバーでページを生成するため時間がかかり、その結果、Time to First Byte（TTFB）が遅くなることがよくあります。
サーバーレンダリングがアプリケーションにとって十分かどうかは、どのようなエクスペリエンスを構築するかに大きく依存します。
サーバーレンダリングとクライアントサイドレンダリングの正しい適用方法については、長年にわたって議論が行われていますが、あるページにはサーバー レンダリングを使用し、別のページには使用しないという選択が可能であることを覚えておくことが重要です。
ハイブリッドレンダリング技術を採用して成功を収めているサイトもあります。Netflix では、比較的静的なランディング ページをサーバー レンダリングし、インタラクションの多いページの JS をプリフェッチして、クライアント レンダリングの重いページをより速くロードできるようにしています。
最近のフレームワーク、ライブラリ、アーキテクチャの多くは、クライアントとサーバーの両方で同じアプリケーションをレンダリングすることを可能にしています。
これらの技術はサーバー レンダリングに使用できますが、サーバーとクライアントの両方でレンダリングが行われるアーキテクチャは、非常に異なるパフォーマンス特性とトレードオフを持つ独自のソリューションのクラスであることに注意することが重要です。
Reactのユーザーは、サーバーレンダリングにrenderToString()またはNext.jsのようなReactをベースにしたソリューションを使用することができます。
Vueのユーザーは、VueのサーバーレンダリングガイドやNuxtを見ることができます。
AngularにはUniversalがあります。
しかし、ほとんどの一般的なソリューションは、何らかの形でハイドレーションを採用しているので、ツールを選択する前に、使用されているアプローチに注意してください。

### より詳細に Static Site Generation(Prerender) を説明する
Static Rendering はビルド時に実行され、クライアントサイド JS の量が制限されている場合は、最初のペイント、最初のコンテンツ付きペイント、Time To Interactive が高速に実行されます。
サーバーレンダリングとは異なり、ページの HTML をその場で生成する必要がないため、Time To First Byte を常に高速にすることもできます。
一般に、静的レンダリングとは、各 URL に対して個別の HTML ファイルを事前に生成することを意味します。
HTMLレスポンスが事前に生成されるため、静的レンダリングを複数のCDNにデプロイしてエッジキャッシュを活用することができます。

静的レンダリングのためのソリューションは、あらゆる形や大きさで提供されています。
Gatsbyのようなツールは、開発者が自分のアプリケーションがビルドステップとして生成されるのではなく、動的にレンダリングされているように感じられるように設計されています。
JekyllやMetalsmithのような他のツールは、その静的な性質を受け入れ、よりテンプレート駆動型のアプローチを提供します。
静的なレンダリングの欠点は、個々の HTMLファイル をすべての可能な URL に対して生成する必要があることです。
これは、URL が事前に予測できない場合や、固有のページが多数あるサイトでは、困難または実現不可能な場合があります。
Reactのユーザーは、Gatsby、Next.js static export、Naviになじみがあるかもしれませんが、これらはすべてコンポーネントを使ってオーサリングするのに便利です。
静的レンダリングとプリレンダリングの違いを理解することが重要です。静的レンダリングのページは、クライアントサイドのJSをあまり実行する必要がなくインタラクティブですが、プリレンダリングは、ページを本当にインタラクティブにするためにクライアントで起動しなければならない SPA のファーストペイントまたはファーストコンテンツフルペイントを向上させます。
あるソリューションが静的レンダリングかプリレンダリングかわからない場合は、JavaScript を無効にして、作成したウェブページを読み込むというテストをしてみてください。
静的レンダリングのページでは、JavaScriptを有効にしなくてもほとんどの機能が存在します。プリレンダリングされたページでは、リンクなどの基本的な機能は残っていますが、ページの大部分は不活性な状態になっています。
また、Chrome DevToolsを使ってネットワークをスローダウンさせ、ページがインタラクティブになるまでにどれだけのJavaScriptがダウンロードされたかを観察するのも有効なテストです。
一般に、プリレンダリングでは、インタラクティブにするために多くの JavaScript が必要であり、その JavaScript は、静的レンダリングで使用される Progressive Enhancement のアプローチよりも複雑になる傾向があります。

### SSR と　SSG の違いとはなんだろうか？
サーバーレンダリングは特効薬ではありません。
その動的な性質により、計算オーバーヘッドが大きくなる可能性があります。
多くのサーバー レンダリング ソリューションは早期にフラッシュせず、TTFB を遅らせたり、送信されるデータを 2 倍にしたりします（たとえば、クライアント上の JS で使用されるインライン状態）。
React では、renderToString() は同期とシングルスレッドであるため、遅くなることがあります。
サーバーレンダリングを「正しく」行うには、コンポーネントのキャッシュ、メモリ消費量の管理、メモ化技術の適用、その他多くの懸念事項に対するソリューションを見つけたり構築したりすることが必要です。
一般に、同じアプリケーションをクライアントとサーバーで何度も処理したり再構築したりすることになります。サーバーレンダリングによって何かが早く表示されるようになったからといって、やるべきことが急に少なくなるわけではありません。
サーバーレンダリングは、各URL に対してオンデマンドで HTML を生成しますが、静的なレンダリング コンテンツを提供するよりも時間がかかる場合があります。
追加の作業を行うことができれば、サーバーレンダリングと HTMLキャッシュによって、サーバーレンダリングの時間を大幅に短縮することができます。サーバーレンダリングの利点は、静的レンダリングよりも多くの「ライブ」データを取得し、より完全なリクエスト セットに応答できることです。
パーソナライズを必要とするページは、静的レンダリングではうまく機能しないタイプのリクエストの具体例です。
サーバーレンダリングは、PWAを構築する際にも興味深い決定をもたらすことがある。全ページのサービス ワーカー キャッシングを使用するのがよいのか、それとも個々のコンテンツをサーバーレンダリングするだけでよいのか？　

### より詳細に　Client Side Rendering を説明する
クライアントサイドレンダリング（CSR）とは、JavaScriptを使用してブラウザで直接ページをレンダリングすることです。
すべてのロジック、データフェッチ、テンプレート、ルーティングは、サーバーではなくクライアントで処理されます。
クライアントサイドレンダリングは、モバイル向けに高速化するのが難しい場合があります。最小限の作業を行い、JavaScript の予算を抑え、できるだけ少ない RTT で価値を提供すれば、純粋なサーバー レンダリングの性能に近づくことができます。
重要なスクリプトやデータは、<link rel=preload> を使用してより早く配信することができ、パーサーをより早く動作させることができます。
PRPL のようなパターンは、初期および後続のナビゲーションを即座に感じるようにするために、評価する価値があります。

クライアントサイドレンダリングの主な欠点は、アプリケーションが成長するにつれて、必要な JavaScript の量が増加する傾向があることです。
これは、新しい JavaScriptライブラリ、ポリフィル、およびサードパーティのコードが追加された場合に特に困難となります。
これらのコードは処理能力を競い、ページのコンテンツをレンダリングする前に処理しなければならないことがよくあります。大規模なJavaScriptバンドルに依存するCSRで構築された体験は、積極的なコード分割を検討し、JavaScriptを遅延ロードすること、つまり「必要なときに、必要なものだけを提供する」ことを心がける必要があります。
インタラクティブ性がほとんどない体験では、サーバーレンダリングがこれらの問題に対するよりスケーラブルな解決策になります。

### SSR と CSR との共存
クライアントサイドレンダリングとサーバーレンダリングの両方を行うことで、トレードオフを滑らかにしようとするものです。
フルページロードやリロードなどのナビゲーション要求は、アプリケーションを HTML にレンダリングするサーバーによって処理され、レンダリングに使用する JavaScript とデータは、結果のドキュメントに埋め込まれます。
慎重に実装すれば、サーバー レンダリングのように高速な First Contentful Paint を実現し、その後、hydration という技術を使ってクライアントで再度レンダリングすることで「持ち直す」ことができるのです。
これは斬新なソリューションですが、パフォーマンス面でかなりの欠点があります。
SSRとリハイドレーションの主な欠点は、ファーストペイントが改善されても、Time To Interactiveに大きな悪影響を及ぼす可能性があることです。
SSRを適用したページは、見た目には負荷がかかっていてインタラクティブに見えますが、実際にはクライアント側のJSが実行され、イベントハンドラがアタッチされるまで入力に応答することができないことがよくあります。
これは、モバイルでは数秒から数分かかることもあります。
ページを読み込んだように見えても、クリックやタップをしても何も反応がないという経験はありませんか？
なぜ何も起こらないのか？なぜスクロールできないのだろう？

#### Rehydration の問題 
JSによるインタラクティビティの遅延よりも深刻な場合があります。
クライアントサイドのJavaScriptが、サーバーがHTMLを表示するために使用したすべてのデータを再要求することなく、サーバーが去った場所を正確に「拾う」ことができるように、現在のSSRソリューションは一般的にUIのデータ依存からの応答をスクリプトタグとして文書内にシリアライズします。
その結果、HTML文書には高いレベルの重複が含まれます。 ご覧のように、サーバーはナビゲーション要求に応じてアプリケーションの UI の説明を返しますが、その UI を構成するために使用されるソースデータ、およびクライアントで起動する UI の実装の完全なコピーも返しています。
bundle.jsの読み込みと実行が終了して初めて、このUIはインタラクティブになります。
SSR rehydrationを使用している実際のウェブサイトから収集したパフォーマンスメトリクスは、その使用を大幅に控えるべきであると示しています。
最終的に、その理由はユーザーエクスペリエンスに帰結します。ユーザーを「不気味の谷」に置き去りにすることになりがちだからです。
しかし、rehydration を伴うSSRには希望があります。短期的には、キャッシュ性の高いコンテンツにSSRを使用するだけで、TTFB遅延を低減し、プリレンダリングと同様の結果を得ることができます。
段階的、漸進的、または部分的に水分を補給することが、将来的にこの技術をより実用的なものにする鍵になるかもしれません。