# よく使うHTTPヘッダを理解する 
[課題内容](https://airtable.com/appPxhCPFYGqqN9YU/tblVlFr2q4lIqDKYc/viwX8r6DpCRp80swL/reclp9trPncjufytK?blocks=hide)

## 課題１（質問）

### 以下のヘッダーの意味と、役割を説明してください
#### Host
Host は、リクエストが送信される先のサーバーのホスト名とポート番号を指定します。

ポート番号が指定されなかった場合は、request されたサービスの既定のポート（例えば HTTPS の URL であれば443、 HTTP の URL であれば 80）とみなされます。
Host はすべての HTTP/1.1 リクエストメッセージで送信する必要があります。 HTTP/1.1 リクエストメッセージに Host ヘッダー項目がなかったり、二つ以上あったりした場合は 400 (Bad Request) ステータスコードが返されることがあります。

#### Content-type
Content-Type は、リソースのメディア種別を示すために使用します。
レスポンスにおいては、クライアントに返されたコンテンツの実際の種類を伝えます。ブラウザーは MIME を推定し、このヘッダーの値に従わないこともあります。 X-Content-Type-Options を `nosniff` に設定すると、この動作を防ぐことができます。
リクエストにおいては (POST または PUT などで)、クライアントがサーバーに実際に送ったデータの種類を伝えます。

#### User-Agent
User-Agent は、サーバーやネットワークピアがアプリケーション、オペレーティングシステム、ベンダーや、リクエストしているユーザーエージェントのバージョン等を識別できるようにする特性文字列です。

#### Accept
Accept は、クライアントが理解できるコンテンツタイプを MIME タイプで伝えます。 コンテンツネゴシエーションを使用して、サーバーは提案のうちの一つを選択し、それを使用してクライアントに Content-Type レスポンスヘッダーで選択を伝えます。ブラウザーはリクエストを行う場面に応じて適切な値をこのヘッダーに設定します。 CSS スタイルシートを取得するときは、画像、動画、スクリプトを取得するときとは異なる値をリクエストで設定します。

#### Referer
Referer には、現在リクエストされているページへのリンク先を持った直前のウェブページのアドレスが含まれています。 
Referer により、サーバーは人々がどこから訪問しに来たかを識別し、分析、ログ、キャッシュの最適化などに利用することができます。

**次のような場合は、ブラウザーは Referer ヘッダーを送信しません。**
- 参照していたリソースがローカルの "file" または "data" の URI の場合
- 安全ではない HTTP リクエストが使用されており、それを参照しているページが安全なプロトコル (HTTPS) で受信された場合

#### Accept-Encoding
Accept-Encoding は HTTP のリクエストヘッダーで、クライアントが理解することができるコンテンツのエンコーディング（ふつうは圧縮アルゴリズム）を示します。
コンテンツ交渉を使用して、サーバーは提案されたものから一つを選択して使用し、 Content-Encoding レスポンスヘッダーを使用してクライアントに選択結果を知らせます。

クライアントとサーバーが同じ圧縮アルゴリズムに対応していた場合でも、 `identity` の値が受け付けられる場合は、サーバーはレスポンスの本体を圧縮しないことを選択する場合があります。

**これには主に 2 つの場合があります。**
- 送信されるデータがすでに圧縮されており、 2 回目の圧縮によって送信するデータが小さくならない場合。これは圧縮を伴う画像形式（JPEG など）が該当します。
- サーバーが過負荷になってもり、圧縮に必要な計算上のオーバーヘッドの余裕がない場合。通常、 Microsoft はサーバーが計算能力の 80% 以上を使用している場合、圧縮しないことを推奨しています。
`identity` の値、つまりエンコードをしないということは、 `identity;q=0` または `*;q=0` で `identity` とは別な値が明確に設定されていない限り、サーバーは 406 Not Acceptable エラーを返してはいけません。

#### Authorization
HTTP の Authorization リクエストヘッダーは、ユーザーエージェントがサーバーから認証を受けるための証明書を保持し、ふつうは、必ずではありませんが、サーバーが 401 Unauthorized ステータスと WWW-Authenticate ヘッダーを返した後に使われます。

#### Location
Location レスポンスヘッダーはリダイレクト先の URL を示します。 3xx (リダイレクト) または 201 (created) ステータスレスポンスを返すときのみ意味を成します。

リダイレクトの場合、 HTTP メソッドは元のメソッドとリダイレクトの種類によって、 Location で示されたページにアクセスする新しいリクエストを生成するために使用します。

- 303 (See Also) レスポンスは常に GET メソッドを使用するように誘導され、 307 (Temporary Redirect) および 308 (Permanent Redirect) は元のリクエストにおいて使用されたメソッドを変更しません。
- 301 (Moved Permanently) と 302 (Found) は多くの場合はメソッドを変更しませんが、古いユーザーエージェントは変更することがあります (そのため、基本的に結果は不明です)。

これらのステータスコードを持つすべてのレスポンスは、 Location ヘッダーを送信します。

リソース作成 (created) では、新しく作成されたリソースへの URL を示します。

Location と Content-Location は異なります。 Location ヘッダーは、リダイレクトの対象 (または新しく作成されたリソースの URL) を示し、 Content-Location ヘッダーはコンテンツネゴシエーションが起きたとき、更なるコンテンツネゴシエーションが起きないように、リソースへアクセスできる直接的な URL を指します。 Location はレスポンスに関連付くヘッダーで、 Content-Location は返されるエンティティに関連付けられます。

### refererについて
- `rel=noreferrer`を設定しなかった場合に起きうる問題を調べて、説明して下さい
まず、`noreferrer`とは <a>, <area>, <form> の各要素の **rel 属性** に指定すると、ターゲットリソースへ移動する際、 `Referer ヘッダー`を省略してリファラー情報が漏洩しないようにブラウザーに指示します。 それに加えて、 noopener キーワードを設定しているかのように動作します。

- リンク先に指定したサイトが悪意あるサイトであったり、ハッキングされているサイト(実質悪意あるサイトの振る舞いをするサイト)だった場合に、リンク先から自分の見ていたリンク元ページが操作されるリスクがある
- 今まではリンク先のページからリンク元のページへの参照があるために、互いにメモリを共有する必要があり、どうしても同じプロセスで実行しなければならず、結果として Spectre の影響を受ける可能性がありました *1

モダンブラウザでは、`noreferrer noopener`を使用しなくても良さそうである。

▼ 参考
https://web.dev/i18n/ja/external-anchors-use-rel-noopener/

## 課題２（クイズ）
- HTTPヘッダーに関するクイズを3問、作成してください


## 課題３（クイズ）

様々なHTTPメソッドがありますが（GET/POST/PUT/PATCH/FETCHなど）、実現したいユースケースに適したメソッドを選択するのは意外と（特に更新系）大変です。例えば以下のケースを考えてみてください：
Twitterのフォロー関係の破棄はPUT?PATCH?DELETE?
取引の取り消しはPUT?PATCH?DELETE?
お気に入りリストからの削除はPUT?PATCH?DELETE?
どこまでHTTPメソッドを本来の定義に沿って使うべきか、ペアと話し合ってみてください。参考としてSlackやTwitterなど有名サービスのAPIのドキュメントを読んでみると良いかもしれません！
